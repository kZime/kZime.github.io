<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[归档计划]]></title>
    <url>%2F2017%2F09%2F03%2F%E5%BD%92%E6%A1%A3%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[# 欧几里得算法 扩展欧几里得算法 快速幂 逆元 中国剩余定理 BSGS 和 EX-BSGS 矩阵乘法 高斯消元 行列式 Miller-Rabin Pollard-Rho 线性筛 组合数 数论函数 莫比乌斯反演 原根 Fast Fourier Transformation Fast Number-Theoretic Transform 斯特林数 群论 Burnside 引理 Pólya 定理 博弈论 杜教筛 *单纯形线性规划 *Fast Walsh-Hadamard Transform *母函数 *高精度 # 字符串 Hash KMP 扩展 KMP Trie Suffix Automation Suffix Array Manacher Aho-Corasick Automation Palindrome Automation 最小表示法 *Suffix Tree *Palindrome Tree *Suffix Balanced Tree *regex.h # 搜索 双向搜索 A* 迭代加深 折半搜索 状态压缩 # 数据结构 Binary Indexed Tree Hash Map Union-Find Set Dancing Links Priority Queue K-Dimensional Tree Mergeable Heap Segment Tree ZKW Segment Tree Sparse Table Balanced Tree Link-Cut Tree Dominator Tree RMQ 树链剖分 点分治 点分树 分块 可持久化数据结构 启发式合并 虚树 带花树 *块状链表 *跳跃链表 *块状树 *长链剖分 # 图论 最短路 第$k$短路 次短路 差分约束系统 最小生成树 次小生成树 连通分量 割点割边 拓扑排序 最大流 费用流 上下界网络流 最大匹配 最大权匹配 2-SAT 欧拉回路 最小树形图 *仙人掌 # 计算几何 基本关系 多边形 凸包 半平面交 旋转卡壳 圆 爬山 模拟退火 随机增量法 *三维几何 *高维几何 # 动态规划 经典 dp 模型 线性 dp 多路 dp 环形 dp 树型 dp 记忆化搜索 数位 dp 状压 dp 单调性优化 决策性优化 斜率优化 四边形不等式优化 期望 dp 插头 dp # 其他 分治 CDQ 分治 莫队 整体二分 01-分数规划 用了一些奇技淫巧, 非常可耻的从xehoth扣过来的quq]]></content>
      <tags>
        <tag>OI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++读入比较]]></title>
    <url>%2F2017%2F06%2F19%2Finput%2F</url>
    <content type="text"><![CDATA[数据: 1e7 数据范围: int 重定向文件读入 优化: 无 cin1234567891011121314# include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k; &#125;&#125;/* real 0m8.912s user 0m8.844s sys 0m0.048s*/ cin 取消兼容stdio123456789101112131415# include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int n, k; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k; &#125;&#125;/* real 0m1.897s user 0m1.844s sys 0m0.032s*/ scanf1234567891011121314# include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n, k; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;k); &#125;&#125;/* real 0m2.180s user 0m2.140s sys 0m0.028s*/ getchar()123456789101112131415161718192021# include &lt;bits/stdc++.h&gt;using namespace std;inline int gn() &#123; int k = 0, f = 1; char c = getchar(); for(; !isdigit(c); c = getchar()) if(c == '-') f = -1; for(; isdigit(c); c = getchar()) k = k * 10 + c - '0'; return k * f;&#125;int main() &#123; int n, k; n = gn(); for(int i = 1; i &lt;= n; i++) &#123; k = gn(); &#125;&#125;/* real 0m1.642s user 0m1.588s sys 0m0.052s*/ fread()12345678910111213141516171819202122232425# include &lt;bits/stdc++.h&gt;using namespace std;inline char getc() &#123; static char buf[1 &lt;&lt; 18], *fs, *ft; return (fs == ft &amp;&amp; (ft = (fs = buf) + fread(buf, 1, 1 &lt;&lt; 18, stdin)), fs == ft) ? EOF : *fs++;&#125;inline int gn() &#123; register int k = 0, f = 1; register char c = getc(); for(; !isdigit(c); c = getc()) if(c == '-') f = -1; for(; isdigit(c); c = getc()) k = k * 10 + c - '0'; return k * f;&#125;int main() &#123; int n, k; n = gn(); for(int i = 1; i &lt;= n; i++) &#123; k = gn(); &#125;&#125;/* real 0m0.648s user 0m0.608s sys 0m0.036s*/ 显而易见，在OI系列比赛中，快读保平安233]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[题目] 网络流和线性规划24题]]></title>
    <url>%2F2017%2F06%2F19%2FNetwork-flow%2F</url>
    <content type="text"><![CDATA[好久之前就想搞个这个了。。 问题编号 问题名称 问题模型 转化模型 完成情况 1 飞行员配对方案问题 二分图最大匹配 网络最大流 √ 2 太空飞行计划问题 最大权闭合图 网络最小割 √ 3 最小路径覆盖问题 有向无环图最小路径覆盖 网络最大流 4 魔术球问题简化/普通 有向无环图最小路径覆盖 网络最大流 5 圆桌问题 二分图多重匹配 网络最大流 √ 6 最长递增子序列问题 最多不相交路径 网络最大流 √ 7 试题库问题 二分图多重匹配 网络最大流 8 机器人路径规划问题 (未解决) 最小费用最大流 9 方格取数问题 二分图点权最大独立集 网络最小割 10 餐巾计划问题 线性规划网络优化 最小费用最大流 11 航空路线问题 最长不相交路径 最小费用最大流 12 软件补丁问题 最小转移代价 最短路径 13 星际转移问题 网络判定 网络最大流 14 孤岛营救问题 分层图最短路径 最短路径 15 汽车加油行驶问题 分层图最短路径 最短路径 16 数字梯形问题 最大权不相交路径 最小费用最大流 17 运输问题 网络费用流量 最小费用最大流 18 分配问题 二分图最佳匹配 最小费用最大流 19 负载平衡问题 最小代价供求 最小费用最大流 20 深海机器人问题 线性规划网络优化 最小费用最大流 21 最长k可重区间集问题 最大权不相交路径 最小费用最大流 22 最长k可重线段集问题 最大权不相交路径 最小费用最大流 23 火星探险问题 线性规划网络优化 最小费用最大流 24 骑士共存 二分图最大独立集 网络最小割 markdown 打这个表炒鸡累啊啊啊]]></content>
      <categories>
        <category>题目</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[BYVoid S1] 灵魂分流药剂]]></title>
    <url>%2F2017%2F06%2F19%2Fsoultap%2F</url>
    <content type="text"><![CDATA[题面 幽暗城皇家炼金师赫布瑞姆刚刚发明了一种用来折磨战俘的新型药 剂，这种药剂被称为灵魂分流药剂。灵魂分流药剂的妙处在于能够给战俘带来巨大的痛苦，但是却不会让战俘死去。这种药剂中包含了一些治疗的成分，所以即使战 俘想自尽，也会被救活。用这种求生不得，求死不能的感觉，来对付反对希尔瓦娜斯女王的狂徒们，实在是太美妙了。当然，灵魂分流药剂要限定在一个用量范围之 内，过少会达不到效果，而过多会直接杀了战俘。 最近，我们抓获了一个来自暴风城的探子，他掌握了我们的许多重要情报。希尔瓦娜斯女王命令你用最痛苦的手段折磨他。你从你的导师，灵魂分流药剂的发明者——皇家炼金师赫布瑞姆那里获得了N瓶药剂。每瓶按照药性的不同装在M个箱子中。每瓶药剂都有一个规格：对服用者造成的肉体伤害w，对服用者造成的意志折磨v，所属的箱子t，和对服用者造成的痛苦值p。 据我们测试，那个暴风城探子的生命值为A，意志力为B。你要从每个箱子中最多拿取1瓶药剂喂给他。注意，喂给他的药剂造成的总肉体伤害不能超过他的生命值A，否则他会死去，总意志折磨不能超过他的意志力B，否则他会精神崩溃，我们没有必要给一个精神崩溃的傻瓜制造那么多痛苦。在不让他死去或者精神崩溃的前提下，你要尽可能多的给他制造痛苦，你能解决这个问题吗？ 输入格式 第1行：四个整数N,M,A,B，M个箱子的编号为1..M。 第2行至第N+1行：第i+1行四个整数w,v,t,p表示第i瓶药剂的肉体伤害，意志折磨，所属箱子的编号，和造成的痛苦值。 输出格式 第1行：一个整数，表示能够造成的最大的痛苦值。 样例input1234565 3 20 205 10 1 20010 5 1 1008 11 2 5610 10 2 505 5 3 100 output1300 数据规模 对于30%的数据 N&lt;=30 M&lt;=5 对于100%的数据 N&lt;=100 M&lt;=10 A,B&lt;=100 思路裸的二维背包。。注意数据格式 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# include &lt;bits/stdc++.h&gt;using namespace std; inline char getc() &#123; static char buf[1 &lt;&lt; 18], *fs, *ft; return (fs == ft &amp;&amp; (ft = (fs = buf) + fread(buf, 1, 1 &lt;&lt; 18, stdin)), fs == ft) ? EOF : *fs++;&#125; inline int gn() &#123; register int k = 0, f = 1; register char c = getc(); for(; !isdigit(c); c = getc()) if (c == '-') f = -1; for(; isdigit(c); c = getc()) k = k * 10 + c - '0'; return k * f;&#125; int f[102][102][102], n, m, a, b, w[102], v[102], p[102], ans;vector &lt;int&gt; box[12]; int main() &#123; # ifndef LOCAL freopen("soultap.in", "r", stdin); freopen("soultap.out", "w", stdout);# else freopen("in", "r", stdin);# endif n = gn(), m = gn(), a = gn(), b = gn(); for(int t, i = 1; i &lt;= n; i++) &#123; w[i] = gn(), v[i] = gn(), t = gn(), p[i] = gn(); box[t].push_back(i); &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 0; j &lt;= a; j++) &#123; for(int k = 0; k &lt;= b; k++) &#123; f[i][j][k] = f[i - 1][j][k]; &#125; &#125; for(int o = 0; o &lt; box[i].size(); o++) &#123; int tmp = box[i][o]; for(int j = w[tmp]; j &lt;= a; j++) &#123; for(int k = v[tmp]; k &lt;= b; k++) &#123; f[i][j][k] = max(f[i][j][k], f[i - 1][j - w[tmp]][k - v[tmp]] + p[tmp]); ans = max(ans, f[i][j][k]); &#125; &#125; &#125; &#125; printf("%d\n", ans);&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO5.4]奶牛的电信Telecowmunication]]></title>
    <url>%2F2017%2F06%2F18%2FTelecowmunication%2F</url>
    <content type="text"><![CDATA[题面描述 农夫约翰的奶牛们喜欢通过电邮保持联系，于是她们建立了一个奶牛电脑网络，以便互相交流。这些机器用如下的方式发送电邮：如果存在一个由c台电脑组成的序列a1,a2,…,a(c)，且a1与a2相连，a2与a3相连，等等，那么电脑a1和a(c)就可以互发电邮。 很不幸，有时候奶牛会不小心踩到电脑上，农夫约翰的车也可能碾过电脑，这台倒霉的电脑就会坏掉。这意味着这台电脑不能再发送电邮了，于是与这台电脑相关的连接也就不可用了。 有两头奶牛就想：如果我们两个不能互发电邮，至少需要坏掉多少台电脑呢？请编写一个程序为她们计算这个最小值。 以如下网络为例: ​ 1 / 3 —- 2 这张图画的是有2条连接的3台电脑。我们想要在电脑1和2之间传送信息。电脑1与3、2与3直接连通。如果电脑3坏了，电脑1与2便不能互发信息了。 输入格式 第一行 四个由空格分隔的整数：N,M,c1,c2.N是电脑总数，电脑由1到N编号。M是电脑之间连接的总数。最后的两个整数c1和c2是上述两头奶牛使用的电脑编号。连接没有重复且均为双向的(即如果c1与c2相连，那么c2与c1也相连)。两台电脑之间至多有一条连接。电脑c1和c2不会直接相连。 第2到M+1行 接下来的M行中，每行包含两台直接相连的电脑的编号。 输出格式 一个整数表示使电脑c1和c2不能互相通信需要坏掉的电脑数目的最小值。 样例输入1233 2 1 21 32 3 输出11 数据范围 1&lt;=N&lt;=100, 1&lt;=M&lt;=600 思路求最小割点集的大小 将每个点拆成点$u$和点$u + n$，从$u$到$u+ n$ 连一条边权为$1$的边。 12addedge(u, u + n, 1);addedge(u + n, u, 0); 对于图中原来存在的边$u \implies v$ ，使$u + n$连向$v$， $v + n$ 连向$u$ ，边权都为无穷大。 1234addedge(u + n, v, INF);addedge(v, u + n, 0);addedge(v + n, u, INF);addedge(u, v + n, 0); 然后对然后以源点$S + n$，汇点$T$跑一边最大流就行了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# include &lt;bits/stdc++.h&gt;# define MAXN 123# define INF 0x7fffffffusing namespace std;inline char getc() &#123; static char buf[1 &lt;&lt; 18], *fs, *ft; return (fs == ft &amp;&amp; (ft = (fs = buf) + fread(buf, 1, 1 &lt;&lt; 18, stdin)), fs == ft) ? EOF : *fs++;&#125;inline int gn() &#123; register int k = 0, f = 1; register char c = getc(); for(; !isdigit(c); c = getc()) if(c == '-') f = -1; for(; isdigit(c); c = getc()) k = k * 10 + c - '0'; return f * k;&#125;struct edge &#123; int to, w, ne; edge() &#123;;&#125; edge(int to_, int w_, int ne_) &#123; to = to_, ne = ne_, w = w_; &#125;&#125;e[MAXN &lt;&lt; 5];int cnt, head[MAXN &lt;&lt; 1], s, t, n, m;inline void addedge(int fr, int to, int w) &#123; e[cnt] = edge(to, w, head[fr]), head[fr] = cnt++; e[cnt] = edge(fr, 0, head[to]), head[to] = cnt++;&#125;int dis[MAXN &lt;&lt; 1];queue &lt;int&gt; q;inline bool bfs() &#123; memset(dis, -1, sizeof(dis)); q.push(s); dis[s] = 0; while(!q.empty()) &#123; int u = q.front(); q.pop(); for(int i = head[u]; ~i; i = e[i].ne) &#123; int v = e[i].to; if(!~dis[v] &amp;&amp; e[i].w &gt; 0) &#123; dis[v] = dis[u] + 1; q.push(v); &#125; &#125; &#125; return ~dis[t];&#125;int dfs(int u, int val) &#123; int rec = 0; if(u == t) return val; for(int i = head[u]; ~i; i = e[i].ne) &#123; int v = e[i].to; if(dis[v] == dis[u] + 1 &amp;&amp; e[i].w &gt; 0 &amp;&amp; (rec = dfs(e[i].to, min(val, e[i].w)))) &#123; e[i].w -= rec; e[i ^ 1].w += rec; return rec; &#125; &#125; return 0;&#125;inline int max_flow() &#123; int ans = 0, u; while(bfs()) &#123; while(u = dfs(s, INF)) ans += u; &#125; return ans;&#125;int main() &#123; memset(head, -1, sizeof(head)); n = gn(), m = gn(), s = gn() + n, t = gn(); for(int i = 1; i &lt;= n; i++) addedge(i, i + n, 1); for(int x, y, i = 1; i &lt;= m; i++) &#123; x = gn(), y = gn(); addedge(x + n, y, INF); addedge(y + n, x, INF); &#125; printf("%d\n", max_flow());&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zkw线段树！！！]]></title>
    <url>%2F2017%2F05%2F08%2Fzkw%2F</url>
    <content type="text"><![CDATA[ZKW线段树！！！ 出处 : 统计的力量 by THU张昆玮 跟普通线段树的区别： 非递归调用， 常数小 堆式满二叉树储存，是点树 信息向上传递 大概来一张图来表现普通线段树与zkw重口味线段树的储存方式的差距。 这个是普通的线段树zkw线段树 qwq有没有dalao安利我绘图工具啊，windows自带画板快把强迫症逼死了啊啊啊啊啊 是不是非常的简单明了==反正就是能够发现，你可以很快的找到叶子节点的位置作为二叉树，线段树的标号是这样的转换成二进制之后是这样的很显然nd[x]的父亲节点是nd[x &gt;&gt; 1], 而nd[x]的两个儿子节点的标号分别是nd[x &lt;&lt; 1]和nd[x &lt;&lt; 1 | 1]. 接下来是求区间和的各个操作的演示代码 inline void build()建树十分简单PS: 为了保证叶子节点都在同一层，必须保证最后一层的节点数量是大于n的最小的2的幂，也就是代码中的M123456789101112131415inline void push_up(int x) &#123; // 上传过程 nd[x] = nd[x &lt;&lt; 1] + nd[x &lt;&lt; 1 | 1];&#125;inline void build() &#123; while(M &lt;= n + 1) &#123; // M可以等于n 所以要M &lt;= n + 1 M &lt;&lt;= 1; &#125; for(int i = M + 1; i &lt;= M + n; i++) &#123; // 处理叶子节点 nd[i] = get_num(); &#125; for(int i = M; i &gt;= 1; i--) &#123; // 处理父节点 push_up(i); &#125;&#125; 叶子节点所在的层上的节点数为M， 叶子结点之前的节点数也是M，然后更新过程就可以这样的优美 inline void change_one_point(int x, int k)单点修改的过程也是十分的简单， 只需要找到要修改的值所在的叶子节点，更新之后一路往上传就行, 时间复杂度O(logn)1234567inline void change_one_point(int x , int k) &#123; x += M; nd[x] += k; for(x &gt;&gt;= 1; x; x &gt;&gt;= 1) &#123; push_up(x); &#125;&#125; inline void change_section(int l, int r, int k)这是个坑，暂时不解决 inline int query(int l, int r)12345678inline int query(int l, int r) &#123; int ans = 0; for(l = M + l - 1, r = M + r + 1; l ^ r ^ 1; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123; // l = M + l - 1, r = M + r + 1, 意思是将l 和 r 变成开区间，l ^ r ^ 1 --&gt; not l ^ r == 1 --&gt; l 和 r不是同一节点的两个子节点 if(~l &amp; 1) ans += nd[l + 1];// l是左子区间 if(r &amp; 1) ans += nd[r - 1]; // r是右子区间 &#125; return ans;&#125; 一大坨毒瘤的位运算。。。每个位运算的意思都在代码里解释了，如果还是感觉毒瘤可以尝试看看zkw论文里的伪代码 未完待续…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客重建]]></title>
    <url>%2F2017%2F05%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[因为自己乱搞Ubuntu，在Ubuntu下进行了一些类似于 cd /sudo rm -rf 的错误操作，导致Ubuntu系统崩盘，顺带清了一个盘甚至电脑启动不了了几次磁盘恢复就恢复出来几篇文章，剩下的还有自己去网上抠。。惨死。。 嗯，就假装是一次博客升级吧，恢复文章的过程还顺便去fock了别人的一个主题，估计是码代码时候熟悉黑色背景了，这款主题也是看着很舒服，也算很开心吧。这次集训我在课余时间重装了数十次Ubuntu，虽然很崩溃吧，但是学到了很多， 还搞到了一个非常爽的编辑器atom， 强推。震惊！kZime看了之后连Vim都弃了！ 就是这种感觉。 Vim虽然有着很棒的码代码的手感，但编译，调试时甚是麻烦，而且代码补全插件我一直搞不好qwq，就很气，但atom不仅手感好，各种插件也做的很方便。有一个小细节我要点个赞，之前不管是devc还是vim，关于编码方面都处理的不是太好，vim还行，认死一个UTF-8就够了，但devc会把UTF-8的代码注释弄成乱码，在devc是的代码注释移动到vim又成乱码了，notepad++在这块做的还好，至少可以很方便的转换编码。atom而可以直接在编辑器右下角调成自动选择编码模式，这样就很爽了。而且atom作为github的产品，开源免费是必须的，还可以直接在atom呢下载github上的插件，主题。vim模式插件不用说，连Emacs插件也有。还有强大的自定义功能，加上几个插件， 就可以说是IDE了。]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CF#410div2]]></title>
    <url>%2F2017%2F04%2F22%2FCF-410div2%2F</url>
    <content type="text"><![CDATA[这次比赛是真的开心，是在省选集训的时候和省实验的zf和mk一起打的，先是打到11点45， 然后跑到楼下创客活动室躲到比赛结束才会楼上机房，正准备继续写题的时候去组团上厕所的mk和zf突然跑回来让关灯躲起来，躲到凌晨1点才敢开灯，就直接去睡觉了。睡前和mk，zf聊了很多。 真心祝愿MK学长省选进队！！（不是奶 明天就是省选了 JLOI, HEOI, HLOI, SHOI, SNOI, HAOI, SXOI, FJOI, LNOI, GZOI BLESS ALL 1while(true) RP++;]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2017游记]]></title>
    <url>%2F2017%2F04%2F22%2FHAOI2017%2F</url>
    <content type="text"><![CDATA[OI生涯经历的第一场省选，惨烈无比纪念syz18界学长 XTT, TYS, DCHssy18界学长学姐 MK, KZNS, 农场主， 克泽风， DAY -7 周日和一群dalao去参加轻院校赛，和wb，学长tys一队，队名很鬼畜。 开考读题，直接把一道看上去很水的最短路D递给tys了，然后wb继续看题，我看着tys码spfa，感觉没什么问题犹豫了一下，提交了，直接RE，开门GG，心态全无，感觉是边数开小了，又交了一次，仍然RE。。慌得直接换题。然后我和wb讨论A题的三维坐标下点到直线的距离，推广不出来。换题，看到E题以为是个很简单的贪心，交给tys，打着打着突然感觉不对劲，少考虑好多影响（结束后问了才知道是个网络流。。。，考试中间评测服务器掉线，写了4道题，服务器上线后交完连WA带TLE加RE。。最后只A了两道题，带着狗牌走掉。天天队伍A了8道题，拿到了rk3，一中mjl两人队A8题rk2，mjl太强了aaaa…离开的时候发誓明年再来参加一定AK全场。 比完赛跟着天天，省实验的人，一中的mjl去吃饭，看速8，然后跟ldl，KZ坐出租回家 DAY -6 ~ -3 在省实验集训，每天上午都在实验内网考试，考到中文12点， 然后我就会和wb一起去学校对面碰碰凉要不是玩王者农药，要不是码代码，平均一次A一道最水的题吧。。考完两天突然把比赛放在192.168.1.12上了，用账户条登陆。然后就体验到省实验著名的颓废机房（233。老师讲的东西基本上听不懂。。。 每天晚上10点去实验操场找粽子，和她散散步，聊聊天。。。开心 DAY -2 ~ -1 白天日常，晚上刷CF，见前一篇博客。然后睡在机房，睡前和mk，zf聊了很多人，很多事，mk睡之前确定的说，感觉自己还是有很大机会进队的，自己很自信自己的水平。我们也希望mk能进队。 日常，不过没比赛，今天wb没来实验，我写了写水题就跟着大家浮了起来，下午，机房里的人都去看考场或者订宾馆了，我见人少，就回家了。 DAY 0上午 早上去郑大找不到考场在哪，转了好几圈，我qq问mjl知道不知道在哪，他也表示懵逼。然后突然在路上发现一只野生的天天，就直接跟着他跑了，找到之后给mjl说考场在哪。（后来看他博客知道他是考前5分钟进的考场。 到考场时已经有点晚了，赶快准备准备环境，安装安装IDE， 突然在D盘资源文件夹里看到了个smartc。我直接喊了一句woc，这玩意我前天在省实验集训的时候才在网上见过，内含各种模板，之前我还玩了半天模板里的游戏。我打开翻了翻，发现里面的代码模板没有被清除，立马预见到这次HAOI又改有问题了。。 t1刚拿到的时候感觉是跟强连通分量，双联通分量什么的有关，但又没思路，就直接码暴力。码到一半脑补出了一个我解决不了的样例，对暴力的正确性产生了怀疑。然后直接放弃，t2直接按照题面意思码一个暴力出来。t3有3种操作，其中只有第一种操作就能过6个点，当时时间也不太够了，直接码起异或版spfa。但是因为样例抄错了耽误了很多时间。码完还剩两分钟玩起了smartc里的俄罗 斯方块。 DAY 0下午 出来之后表示大家写的都是暴力，心态还好。但是TYS专注码t2后缀数组，因为记错一个变量名爆零，其它题一点没码。听我说smartc上有后缀数组的模板后直接个ccf发了封邮件。 下午t1看出来是个DP了，但是题面看不太明白，就先把t2的20分暴力码了，然后t1还是看不懂，就各种玩。电脑里有啥玩啥。 考完mk说感觉自己要擦线进队了。 天天，sxy和杨老师留在那等结果，我们直接回学校，回家。 回家睡到7点回学校。 DAY 1 空间被mjl刷屏了，似乎评测用的lemon内存设置出问题了，好多人mle掉。又有人说下午t1数据太水，不考虑障碍情况的裸dp就过了8个点，然后这几天就各种申诉。在学校学文化课，偶尔会机房码题。 DAY 3 成绩出了mjl rk3强势进队，焦作一中进来3个，安阳一中进了2个，郑州一中进了2个。郑州一中的两个里还都是高一的。Rapiz被学弟擦线挤出队，rk8。省实验没有进队，其中农场主考的最高，mk也没有成功。。 zsb下午t1裸dp过了8个点，120分，sxydalao110分，不知道会不会买D进队，TYS上午爆零，下午拿了90分，拿到一等，我60分，rk23，差1个点一等。。。wb，wzz爆零，天天学长。。爆零。 不知道为什么，本来最有希望，最强的天天爆零了。好像因为函数名写错，文件读入输出写错。。。但感觉好可惜。 然后后面的几天都没看到天天。 DAY 5 省选风波过去了，本来想着OI可以放一放了，学校开了运动会，mjl去济南集训了，cogs上一个邯郸一中的好友也问我要不要去济南，我就自己一人出发了，走上了自己的路。]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF#408div2]]></title>
    <url>%2F2017%2F04%2F11%2FCF-408div2%2F</url>
    <content type="text"><![CDATA[第一次在晚上熬夜打CF，虽然准备的很充足，但还是只A了两道模拟，其中B题还被HACK掉了一次。。。经过mly的指点才把HACK点改掉，然后就是C，刚开始没思路，dalao们确认贪心可做之后就开始瞎JB贪了起来，然后WAWAWAWAWA。。。。结果rating–瘫 多做题吧，骚年 QAQ]]></content>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2014遥感监测题解]]></title>
    <url>%2F2017%2F03%2F27%2Fha14%E6%91%87%E6%9D%86%E7%9B%91%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[[HAOI2014]遥感监测题目描述 外星人指的是地球以外的智慧生命。外星人长的是不是与地球上的人一样并不重要，但起码应该符合我们目前对生命基本形式的认识。比如，我们所知的任何生命都离不开液态水，并且都是基于化学元素碳（C）的有机分子组合成的复杂有机体。ZDM实验室的天文学家们已经执著地观测ZDM-99星球十多年了，这个被称为“战神”的红色星球让他如此着迷。在过去的十多年中，他经常有一些令人激动的发现。ZDM-99星球表面有着明显的明暗变化。对这些明暗区域，天文学家们已经细致地研究了很多年，并且绘制出了较为详尽的地图，那些暗区是陆地，而亮区则是湖泊和海洋。他们一直坚信有水的地方，一定有生命的痕迹。 这天晚上的观测条件实在是空前的好，ZDM-99星球也十分明亮，不时呈现出若干个激光点，天文学家们推定这些激光点极有可能存在地球以外的智慧生命。遗憾的是仅持续很短的一段时间，这些激光点就消失了。 ZDM实验室的射电望远镜观测的区域有限，只可以遥感检测到一个半径为R的圆形区域。为了能同时能检测到所有的激光点，ZDM实验室需要要在一个水平的直线上尽快地安装多个的射电望远镜来。 不妨设，这条安放射电望远镜的水平直线为X轴，ZDM-99星球激光点就处在P1（x1,y1）P2(x2,y2) ，…… ，Pn(xn,yn)。（忽略Z坐标）ZDM实验室的天文学家们想知道，至少需要安装多少个射电望远镜才能检测到所有激光点。 输入格式 第1行: N R 分别表示激光点的个数和射电望远镜能检测到的半径第2~N+1行： Xi Yi 表示 激光点的坐标位置 输出格式 输出一行： 最少需要安装的射电望远镜数。 样例输入 3 21 2-3 12 1 样例输出 2 约束条件 1≤R≤50 1≤N≤100 -1000≤ Xi Yi ≤ 1000 | Yi | ≤ RN，R, Xi Yi都是整数。数据之间有一个空格。 题解大概是个贪心，找出能保证包住最靠左的激光点的最靠右边的x轴坐标，但是枚举所以点时间复杂度明显太高，所以换一种思路，使用结构体处理出每个激光点所能被包住的可以作为望远镜的可行区间 处理方法很简单12345for(int i=1;i&lt;=n;i++)&#123; double fan=sqrt(pow(r,2)-pow(p[i].y,2));//pow()是n次方函数pow(x,n)表示x的n次方 p[i].l=p[i].x-fan; p[i].r=p[i].x+fan;&#125; 然后对处理后的区间按照右端点进行排序(请同学们自主思考：为什么是右端点)然后进行统计12345678910int k=1, ans=1;for(int i=2;i&lt;=n;i++)&#123; if(p[i].l&lt;=p[k].r)&#123;//p[k].r点可观测到点i continue; &#125; else &#123;//更新k k=i; ans++; &#125;&#125; 最后放一下全部代码 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int ans,r,n;inline int read()&#123; int k=0,f=1;char c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())k=k*10+c-'0'; return k*f;&#125;class mp&#123;public: int x; int y; double l; double r;&#125;p[2333];bool cmp(mp a,mp b)&#123; return a.r&lt;b.r;&#125;int main()&#123; freopen("ha14a.in","r",stdin); freopen("ha14a.out","w",stdout); n=read(); r=read(); for(int i=1;i&lt;=n;i++)&#123; p[i].x=read(); p[i].y=read(); if(abs(p[i].y)&gt;r)&#123; cout&lt;&lt;-1; return 0; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; double fan=sqrt(pow(r,2)-pow(p[i].y,2)); p[i].l=p[i].x-fan; p[i].r=p[i].x+fan; &#125; sort(p+1,p+1+n,cmp); int k=1; ans=1; for(int i=2;i&lt;=n;i++)&#123; if(p[i].l&lt;=p[k].r)&#123; continue; &#125; else &#123; k=i; ans++; &#125; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>HAOI</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪念12Dora]]></title>
    <url>%2F2017%2F03%2F25%2F12dora%2F</url>
    <content type="text"><![CDATA[“我所做的一切都是为了守护我亲爱的B站”。 ———— 12dora]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HAOI2013题解]]></title>
    <url>%2F2017%2F03%2F20%2FHAOI2013%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HAOI2013 的特点 题水 谁说的。。。做了大半年的题你跟我说水。。。欸，似乎真的很水。。。大概是我太水吧。。。 T1 [HAOI2013] 跑步训练题目描述 Dr.Kong准备参加冬季越野比赛。为了能在比赛中有好的发挥，他决定每天早上上班前在附近的一条山路上开始训练。他当然希望每次训练中跑得尽可能远，但他的时间有限，每天早上跑步训练的时间不得超过M秒 (1 &lt;= M &lt;= 10,000,000)。为了合理的安排跑步路程，Dr.Kong将整条山路划分成T个长度相同的小段(1 &lt;= T &lt;= 100,000)，并且，分别用u，f，d这3个字母之一来表示每个小段是上坡、平地，或是下坡。 Dr.Kong要花t1秒(1 &lt;= t1 &lt;= 100)才能跑完一段上坡路，跑完一段平地的耗时是t2秒(1 &lt;= t2 &lt;= 100)，跑完一段下坡路要花t3秒(1 &lt;= t3 &lt;= 100)。注意，沿山路原路返回的时候，原本是上坡路的路段变成了下坡路，原本是下坡路的路段变成了上坡路。 Dr.Kong想知道，在不超过M秒内返回的前提下，他最多能在这条山路上跑多远。 输入格式 第1行: M T t1 t2 t3 (数据之间用一个空格隔开) 第2..T+1行: 每行为1个字母u或f或d，描述了相应段的山路路况（上坡、平地，或是下坡） 输出格式 输出1个整数，为Dr.Kong在不超时回到的前提下，最多能跑到几段。 样例输入 13 5 3 2 1ufudf 样例输出 3 cogs评分半星。。。 解法 就是用一个整型s存达到当前步数要走的来回的耗时 然后每走一段路程加上耗时与返回时的耗时，s &gt; M 并且step &lt;= t时结束程序，输出step - 1 贴代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*kZime*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define MAXNusing namespace std;inline int read() &#123; int k = 0, f = 1; char c = getchar(); for(; !isdigit(c); c = getchar())if(c == '-') f = -1; for(; isdigit(c); c = getchar()) k = k * 10 + c - '0'; return k * f;&#125;inline char in_char() &#123; char c = getchar(); for(; !isalpha(c); c = getchar()); return c;&#125;/-----------------------------------------------------------------------------*/int v[3] , m, t, s = 0, step = 0;// v[3] 表示3种地形的速度char c[100233];int main() &#123;#ifndef MYLAB freopen("HAOI2013T1.in", "r", stdin); freopen("HAOI2013T1.out", "w", stdout);#else freopen("in.txt", "r", stdin);#endif m = read(); t = read(); for(int i = 0; i &lt;= 2; i++) &#123; v[i] = read(); &#125; for(int i = 0; i &lt; t; i++) &#123; c[i] = in_char(); &#125; while(s &lt;= m &amp;&amp; step &lt;= t) &#123; if(c[step] != 'f') &#123; // 如果step这一段地形不是平地，总耗时s增加v[0] + v[2] s += v[0] + v[2]; &#125; else &#123;//如果是平地，则总耗时增加两倍的平地耗时 s += v[1] &lt;&lt; 1; &#125; step++; &#125; printf("%d",--step); return 0;&#125; T2[HAOI2013] 花卉节题目描述 ZZ市准备在绿博园举办一次花卉节。Dr.Kong接受到一个任务，要买一批花卉进行布置园林。能投入买花卉的资金只有B元 (1 &lt;= B &lt;= 10^18) 。Dr.Kong决定做一个社会调查，统计一下市民们都喜欢哪种花卉，以便在有限的资金范围内，让更多的市民都能找到并标注一盆自己喜欢的花卉（一盆花只能一位市民标注）。经调查统计，市场上有N (1 &lt;= N&lt;=100,000)种不同类型的花卉，第i种花卉的价格是Pi(1 &lt;= Pi &lt;= 10^18) 。有Ci (1 &lt;= Ci &lt;= 10^18) 个市民喜欢。你能帮助Dr.Kong计算一下，在不透支的情况下，如何购买花卉才能让更多的市民都能找到并标注一盆自己喜欢的花卉？例如：Dr.Kong 有 50块钱，有5种不同类型的花卉：显然，Dr.Kong不能购买第5种类型的花卉,因为他不够钱。下面的购买方案是最优的：第1种花卉买3盆；第2种花卉买1盆；第3种花卉买2盆；第4种花卉买2盆。总共花费：5_3+1_1+10_2+7_2=50，这样，Dr.Kong 最多能让3+1+2+2 =8 人满意。 输入格式 第1行: N B第2..N+1行: Pi Ci （i=1，2，….，N）。 输出格式 一个整数，最多可以让多少市民满意。 样例输入 5 505 31 110 47 260 1 样例输出 8 解法算是一道很简单的贪心吧（是吧，反之就是很水，但因为要用到高精所以不水了（其实还是很水吧。。。先将所有花的种类按照价格从小到大排序，然后尽可能多买便宜的花就行了，所以真的水我也就WA了3遍 贴代码先把低精的代码贴上来 低精50分版高精版随后贴上3/20/2017 6:30:43 PM12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*kZime*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAXN 1000000using namespace std;inline int read() &#123; int k = 0, f = 1; char c = getchar(); for(; !isdigit(c); c = getchar())if(c == '-') f = -1; for(; isdigit(c); c = getchar()) k = k * 10 + c - '0'; return k * f;&#125;/*-----------------------------------------------------------------------------*/struct f&#123; int p, w;&#125;fl[MAXN];int n, m;bool cmp(f a, f b) &#123; return a.w &lt; b.w;&#125;int main() &#123;#ifndef MYLAB freopen("haoi13_t2.in", "r", stdin); freopen("haoi13_t2.out", "w", stdout);#else freopen("in.txt", "r", stdin);#endif n = read(); m = read(); for(int i = 0; i &lt; n; i++) &#123; fl[i].w = read(); fl[i].p = read(); &#125; sort(fl, fl + n, cmp); int s = 0, i = 0, ans = 0; while(s &lt;= m &amp;&amp; i &lt; n) &#123; int temp = fl[i].p * fl[i].w; if(temp + s &lt; m) &#123; s += temp; ans += fl[i].p; i++; &#125; else &#123; ans += (m - s) / fl[i].w; break; &#125; &#125; printf("%d", ans); return 0;&#125; 高精全A版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/*kZime*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAXN 1000000#define ull unsigned long long#define ll long long using namespace std;ull read() &#123; ull k = 0, f = 1; char c = getchar(); for(; !isdigit(c); c = getchar())if(c == '-') f = -1; for(; isdigit(c); c = getchar()) k = k * 10 + c - '0'; return k * f;&#125;/*-----------------------------------------------------------------------------*/struct f&#123; ull p, w;&#125;fl[MAXN];ull n, m;class bn&#123;public: ull s[101], l; string str; bn() &#123; memset(s, 0, sizeof(s)); l = 1; &#125; bn operator + (const ull &amp;b) &#123; s[0] += b; for(int i = 0; i &lt; l || s[i]; i++) &#123; s[i + 1] += s[i] / 10; s[i] %= 10; if(i &gt; l) l = i; &#125; l++; while(!s[l - 1]) l--; return *this; &#125; void output() &#123; for(int i = l - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; (int) s[i]; &#125; &#125;&#125;;bool cmp(f a, f b) &#123; return a.w &lt; b.w;&#125;int main() &#123;#ifndef MYLAB freopen("haoi13_t2.in", "r", stdin); freopen("haoi13_t2.out", "w", stdout);#else freopen("in.txt", "r", stdin);#endif n = read(); m = read(); for(ull i = 0; i &lt; n; i++) &#123; fl[i].w = read(); fl[i].p = read(); &#125; sort(fl, fl + n, cmp); ull s = 0, i = 0; bn ans; while(s &lt;= m &amp;&amp; i &lt; n) &#123; ull temp = fl[i].p * fl[i].w; if(temp + s &lt; m) &#123; s += temp; ans = ans + fl[i].p; i++; &#125; else &#123; ans = ans + (m - s) / fl[i].w; break; &#125; &#125; ans.output(); return 0;&#125; long long 全A版打完高精之后看了看天天的rank2代码突然发现不加高精也能过，然后就换了个结构自己码了一遍，但跑的还是没有天天的快，气哭1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*kZime*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAXN 1000000#define ll long longusing namespace std;inline ll read() &#123; ll k = 0, f = 1; char c = getchar(); for(; !isdigit(c); c = getchar())if(c == '-') f = -1; for(; isdigit(c); c = getchar()) k = k * 10 + c - '0'; return k * f;&#125;/*-----------------------------------------------------------------------------*/struct f&#123; ll p, w;&#125;fl[MAXN];ll n, m;bool cmp(f a, f b) &#123; return a.w &lt; b.w;&#125;int main() &#123;#ifndef MYLAB freopen("haoi13_t2.in", "r", stdin); freopen("haoi13_t2.out", "w", stdout);#else freopen("in.txt", "r", stdin);#endif n = read(); m = read(); for(ll i = 0; i &lt; n; i++) &#123; fl[i].w = read(); fl[i].p = read(); &#125; sort(fl, fl + n, cmp); ll i = 0, ans = 0; while(i &lt; n) &#123; //花种类总数n 当前剩余可支配资金m ll temp = m / fl[i].w; //选择当前花种最多可以满足市民总数temp if(temp &gt; fl[i].p) &#123; ans += fl[i].p; m -= fl[i].p * fl[i].w; i++; &#125; else &#123; ans += temp; break; &#125; &#125; printf("%lld", ans); return 0;&#125; T3[HAOI2013] 开关控制题目描述 元宵节快要到了，某城市人民公园将举办一次灯展。Dr.Kong准备设计出一个奇妙的展品，他计划将编号为1到N的N（1 &lt;= N &lt;= 35）盏灯放置在一个有M条（1 &lt;= M &lt;= 595）边连接的网络节点上。 每盏灯上面都带有一個开关。当按下某一盏灯的开关時，这盏灯本身以及与之有边相连的灯的状态就会改变。状态改变指的是：当一盏灯是亮时，就会被关闭；当一盏灯是关闭时，就会被打开亮着。 现在的问题是，你能帮助Dr.Kong计算一下最少要按下多少个开关，才能把所有的灯都打开亮着（初始状态：所有的灯都是关闭的）。 数据保证至少有一种按开关的方案，使得所有的灯都能被重新打开。 输入格式 第1行: N M第2到第M+1行：每一行有两个由空格隔开的整數，表示两盏灯被一条边连接。 输出格式 一个整数，表示要把所有的灯都打开时，最少需要按下的开关次数。 样例输入 5 61 21 34 23 42 55 3 样例输出 3 解法听天天讲了好久终于搞明白怎么做了。。。首先，证明每个灯按2次之后的的状态和按2次前的状态一样，因此每个灯最多按一次。 其次，想要让保证当前灯的状态是亮着，前提条件是与这个灯相连的灯（包括当前灯）中有奇数个灯的按钮被按过。设g[i][j]表示灯i是否连接到灯j,x[i]表示i这个灯是否被按过。由这条性质，我们发现，可以列出一个方程(xor 为 异或^)异或的性质：相同为0，不同为1然后就是运用高斯消元，讲方程系数消到一个上三角矩阵。 代码实现1234567891011121314151617181920for(int i = 1; i &lt;= n; i++) &#123;//循环的是列 free_yuan[i] = 1; //初始化i行是自由元 for(int j = i; j &lt;= n; j++) &#123;//从i~n循环行 if(!a[j][i]) continue;//如果第j行第i个系数为0，继续 for(int k = i; k &lt;= n; k++) &#123;//交换发现i行j行 swap(a[i][k], a[j][k]); &#125; swap(a[i][0], a[j][0]);//a[i][0]存的是第i行的解（1），别人的代码可能是a[i][n + 1] break; &#125; if(!a[i][i]) continue; //这行存在有自由元 else &#123; free_yuan[i] = 0; for (int j = i + 1; j &lt;= n; j++) &#123;//进行消元操作 if (!a[j][i]) continue; for (int k = i; k &lt;= n; k++) a[j][k] ^= a[i][k]; a[j][0] ^= a[i][0]; &#125; &#125;&#125; 消元之后，因为存在自由元的i行的灯xi可选择开，也可选择不开，因此要进行dfs找结果代码实现123456789101112131415161718192021222324void dfs(int now, int tmp) &#123; if(tmp &gt; ans) return; if(now &lt;= 0) &#123; ans = min(ans, tmp); return; &#125; //深搜边界 if(free_yuan[now]) &#123;//如果now行为自由元 slt[now] = 1; dfs(now - 1, tmp + 1); slt[now] = 0; dfs(now - 1, tmp); &#125; else &#123;//slt[now]为灯now的状态 slt[now] = a[now][0]; for(int i = now + 1; i &lt;= n; i++) &#123;//利用slt[now]化简now行之前的方程组 if (a[now][i]) slt[now] ^= slt[i]; &#125; dfs(now - 1, tmp + slt[now]); &#125;&#125;int main()&#123; dfs(n, 0);&#125; T4[HAOI2013] 软件安装解法需要用到区间的查询与更改，所以自然而然的想到了线段树，但是困难的是线段树要维护什么。这道题要求查询符合长度要求的空区间的起始位置，所以要维护m：区间内最长空区间的长度，mp：区间最长空区间的起始位置。因为一定会有一段区间的最长空区间跨过两个子区间，而又不是两个子区间的最长空区间的情况，所以还要维护两个值lm：区间左端点之后的最长连续空区间的长度，rm：到右端点的最长连续空区间的长度。有了这4个值，才能对区间的最长空区间的起始位置进行查找。还有一点要注意的是因为优先选择左边的可行区间的起点，所以逻辑判断时候要考虑上这种情况。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/*kZime*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAXNusing namespace std;inline int read() &#123; int k = 0, f = 1; char c = getchar(); for(; !isdigit(c); c = getchar())if(c == '-') f = -1; for(; isdigit(c); c = getchar()) k = k * 10 + c - '0'; return k * f;&#125;/*-----------------------------------------------------------------------------*/int n, m;class segtree &#123;public: int l, r, lm, rm, m, mp, tag; //mp指的是最长区间的起始位置 segtree() &#123; tag = -1; &#125; void in(int _l, int _r, int _ml, int _mr, int _m, int _mp, int _tag) &#123; l = _l; r = _r; lm = _ml; rm = _mr; m = _m; mp = _mp; tag = _tag; &#125;&#125;nd[300050];void build(int x, int l, int r) &#123; if(l == r) &#123; nd[x].in(l, r, 1, 1, 1, l, -1); &#125; else &#123; int mid = (l + r) / 2; int len = r - l + 1; build(x &lt;&lt; 1, l, mid); build(x &lt;&lt; 1 | 1, mid + 1, r); nd[x].in(l, r, len, len, len, l, -1); &#125;&#125;void push_down(int k) &#123; if(nd[k].tag == 1) &#123;//该区间已被占满 nd[k].lm = nd[k].rm = nd[k].m = nd[k].mp = -1; nd[k &lt;&lt; 1].tag = 1; nd[k &lt;&lt; 1 | 1].tag = 1; nd[k].tag = -1; &#125; if(nd[k].tag == 0) &#123;//该区间为空区间 nd[k &lt;&lt; 1].tag = nd[k &lt;&lt; 1 | 1].tag = 0; nd[k].lm = nd[k].rm = nd[k].m = (nd[k].r - nd[k].l + 1); nd[k].mp = nd[k].l; nd[k].tag = -1; &#125;&#125;void push_up(int k) &#123; push_down(k); push_down(k &lt;&lt; 1); push_down(k &lt;&lt; 1 | 1); int x1 = nd[k &lt;&lt; 1].m , x2 = nd[k &lt;&lt; 1].rm + nd[k &lt;&lt; 1 | 1].lm, x3 = nd[k &lt;&lt; 1 | 1].m; if(x1 &gt;= x2 &amp;&amp; x1 &gt;= x3) &#123; // 注意！！！这三个判断是有优先级的 nd[k].m = x1; // 优先级 x1 &gt; x2 &gt; x3 nd[k].mp = nd[k &lt;&lt; 1].mp; &#125; else if(x2 &gt;= x3) &#123; nd[k].m = x2; nd[k].mp = nd[k &lt;&lt; 1].r - nd[k &lt;&lt; 1].rm + 1; &#125; else &#123; nd[k].m = x3; nd[k].mp = nd[k &lt;&lt; 1 | 1].mp; &#125; int lenl = nd[k &lt;&lt; 1].r - nd[k &lt;&lt; 1].l + 1; int lenr = nd[k &lt;&lt; 1 | 1].r - nd[k &lt;&lt; 1 | 1].l + 1; nd[k].lm = nd[k &lt;&lt; 1].lm; if(nd[k &lt;&lt; 1].lm == lenl) &#123; nd[k].lm = max(nd[k].lm, nd[k &lt;&lt; 1].lm + nd[k &lt;&lt; 1 | 1].lm);//一定要用max()函数，被占区间的rm可能为-1 &#125; nd[k].rm = nd[k &lt;&lt; 1 | 1].rm; if(nd[k &lt;&lt; 1 | 1].rm == lenr) &#123; nd[k].rm = max(nd[k].rm, nd[k &lt;&lt; 1 | 1].rm + nd[k &lt;&lt; 1].rm); &#125;&#125;int query() &#123; push_down(1); return nd[1].m;&#125;int get_the_smallest_mp (int k, int len) &#123; push_down(k); if(nd[k].m &lt; len) return 0; else if(nd[k].lm &gt;= len) return nd[k].l; else if(nd[k &lt;&lt; 1].m &gt;= len) return get_the_smallest_mp(k &lt;&lt; 1, len); else if (nd[k &lt;&lt; 1].rm &gt;= 0 &amp;&amp; nd[k &lt;&lt; 1 | 1].lm &gt;= 0 &amp;&amp; nd[k &lt;&lt; 1].rm + nd[k &lt;&lt; 1 | 1].lm &gt;= len) return (nd[k &lt;&lt; 1].r - nd[k &lt;&lt; 1].rm + 1); else return get_the_smallest_mp(k &lt;&lt; 1 | 1, len);&#125;void change(int k, int l, int r, int tag) &#123; //更新区间 push_down(k); if(l &lt;= nd[k].l &amp;&amp; nd[k].r &lt;= r) &#123; nd[k].tag = tag; return; &#125; else if(l &gt; nd[k].r || r &lt; nd[k].l) &#123; return; &#125; change(k &lt;&lt; 1, l, r, tag); change(k &lt;&lt; 1 | 1, l, r, tag); push_up(k);&#125;int main() &#123;#ifndef MYLAB freopen("haoi13t4.in", "r", stdin); freopen("haoi13t4.out", "w", stdout);#else freopen("in.txt", "r", stdin);#endif n = read(); m = read(); build(1, 1, n); for(int i = 1; i &lt;= m; i++) &#123; int type = read(); if(type == 1) &#123;//安装应用 int len = read(); if(query() &lt; len) &#123; printf("0\n"); &#125; else &#123; int sm =get_the_smallest_mp(1, len); printf("%d\n", sm); change(1, sm, sm + len - 1, 1);//tag 1 表示占用该区间 &#125; &#125; else &#123; int x = read(); int len = read(); change(1, x, x + len - 1, 0);//tag 0 清空该区间 &#125; &#125; return 0;&#125; T5[HAOI2013] 遥控器解法据说floyd也可以过，感觉好神奇，然而我打了一个模拟，要注意的细节很多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/*kZime*/#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define MAXNusing namespace std;inline int read() &#123; int k = 0, f = 1; char c = getchar(); for(; !isdigit(c); c = getchar())if(c == '-') f = -1; for(; isdigit(c); c = getchar()) k = k * 10 + c - '0'; return k * f;&#125;/*-----------------------------------------------------------------------------*/bool num[10], up, down, _, na[100]; // nc[i] （num cost）从x到i的最小代价 // na[i] （num able）是否能到达iint x, y, ans, nc[100];void init() &#123; for(int i = 1;i &lt;= 3; i++) &#123; num[i] = read(); &#125; up = read(); for(int i = 4; i &lt;= 6; i++) &#123; num[i] = read(); &#125; down = read(); for(int i = 7; i &lt;= 9; i++) &#123; num[i] = read(); &#125; _ = read(); num[0] = read(); x = read(); y = read();&#125;void units() &#123; for(int i = 0; i &lt;= 9; i++) &#123; if(num[i]) &#123; nc[i] = 1; na[i] = 1; &#125; &#125;&#125;void tens() &#123; if(!_)return; for(int i = 1; i &lt;= 9; i++) &#123; if(num[i]) &#123; for(int j = 1; j &lt;= 9; j++) &#123; if(num[j]) &#123; nc[i * 10 + j] = 3; na[i * 10 + j] = 1; &#125; &#125; &#125; &#125;&#125;int dis_up(int a, int b) &#123; //从a一路up到b的代价 if(b &gt;= a)return b - a; else return 100 + b - a; //up到99后回到0&#125;int dis_down(int a, int b) &#123; //从a一路down到b的代价 if(a &gt;= b) return a - b; else return 100 + a - b; //down到0后变成99&#125;void try_num() &#123; //尝试从x直接到y if(na[y]) &#123; ans = min(nc[y], ans); &#125;&#125;void try_up() &#123; if(!up) return; for(int i = 0; i &lt;= 99; i++) &#123; if(na[i]) &#123; ans = min(ans, nc[i] + dis_up(i, y)); &#125; &#125;&#125;void try_down() &#123; if(!down) return; for(int i = 0; i &lt;= 99; i++) &#123; if(na[i]) &#123; ans = min(ans, nc[i] + dis_down(i, y)); &#125; &#125;&#125;int main() &#123;#ifndef MYLAB freopen("HAOI2013T5.in", "r", stdin); freopen("HAOI2013T5.out", "w", stdout);#else freopen("in.txt", "r", stdin);#endif ans = 0x7fffffff; init(); units(); tens(); na[x] = 1; nc[x] = 0; try_num(); try_up(); try_down(); if(ans == 0x7fffffff)printf("-1"); else printf("%d", ans); return 0;&#125; 写在最后话说模块化代码真爽啊]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>HAOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OI]]></title>
    <url>%2F2017%2F03%2F18%2FOI%2F</url>
    <content type="text"><![CDATA[5日之内水完洛谷试炼场听起来好lowB啊QAQ 水个p，回去整HAOI2013的题解]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[就是个测试]]></title>
    <url>%2F2017%2F03%2F18%2Ftest%2F</url>
    <content type="text"><![CDATA[开心开心，hexo的blog终于搞下来了1234#include &lt;cstdio&gt;int main() &#123; printf("hello world");&#125;/*kzime*/ 先来一发hello world]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CF 337A Puzzles (dp)]]></title>
    <url>%2F2017%2F02%2F27%2FCCF%20337A(Puzzles)%20%E6%B0%B4dp%2F</url>
    <content type="text"><![CDATA[题面 time limit per test1 second memory limit per test256megabytes inputstandard input outputstandard output The end of theschool year is near and Ms. Manana, the teacher, will soon have to saygoodbye to a yet another class. She decided to prepare a goodbyepresent for her n students and give each of them a jigsaw puzzle(which, as wikipedia states, is a tiling puzzle that requires theassembly of numerous small, often oddly shaped, interlocking andtessellating pieces).The shop assistant told the teacher that there are m puzzles in theshop, but they might differ in difficulty and size. Specifically, thefirst jigsaw puzzle consists of f1 pieces, the second one consists off2 pieces and so on.Ms. Manana doesn’t want to upset the children, so she decided that thedifference between the numbers of pieces in her presents must be assmall as possible. Let A be the number of pieces in the largest puzzlethat the teacher buys and B be the number of pieces in the smallestsuch puzzle. She wants to choose such n puzzles that A - B is minimumpossible. Help the teacher and find the least possible value of A - B. Input The first line contains space-separated integers n and m(2 ≤ n ≤ m ≤ 50). The second line contains m space-separated integersf1, f2, …, fm (4 ≤ fi ≤ 1000) — the quantities of pieces in thepuzzles sold in the shop. Output Print a single integer — the least possible difference theteacher can obtain. Examples input 4 610 12 10 7 5 22 output 5 一句话题面从m个数中找出差值最小的n个数，然后输出这个最小的差值 思路毕竟A题，水，先排序，然后dp一下区间差值（就是区间里第i+m-1个数减去第i个数），找出最小的差值即可。 123456789101112131415161718192021222324252627//kZime#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,m,a[55],dp[55],rs=1000;inline int read()&#123; int k=0;char f=1,c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())k=k*10+c-'0'; return k*f;&#125;int main()&#123; n=read();m=read(); for(int i=0;i&lt;m;i++)&#123; a[i]=read(); &#125; sort(a,a+m);// for(int i=0;i&lt;m;i++)cout&lt;&lt;a[i]&lt;&lt;" ";// cout&lt;&lt;endl; for(int i=0;i&lt;m-n+1;i++)&#123; dp[i]=a[i+n-1]-a[i]; rs=min(rs,dp[i]); &#125; printf("%d",rs); return 0;&#125;]]></content>
      <categories>
        <category>CSDN搬运</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快读]]></title>
    <url>%2F2016%2F12%2F27%2F%E5%BF%AB%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[自己在CSDN的首博贴贴贴123456inline int read()&#123; int k=0;char f=1,c=getchar(); for(;!isdigit(c);c=getchar())if(c=='-')f=-1; for(;isdigit(c);c=getchar())k=k*10+c-'0'; return k*f;&#125; 养成敲快读的好习惯:) 为成为毒瘤打好基础]]></content>
      <categories>
        <category>CSDN搬运</category>
      </categories>
  </entry>
</search>
